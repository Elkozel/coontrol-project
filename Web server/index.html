<!doctype html>
<html>
  <head>
    <title>Socket.IO chat</title>
  </head>
  <body>
    <p>
      <button id="cst">CST</button>
    </p>
    <p>
      D
      <input type="text" name="dir" id="dir">
      <button id="d">Send</button>
    </p>
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
	<script>
	  // Keep Track of flags recieved
connection = {
  up:false,
  on:false,
  ping: -1
};
options = {
  ping: false,
  pingFreq: 100, 
  dirFreq:15
}




// Keep Track of Keys Pressed
var map = [];
var times = [0,0];
// Check keys
function checkkey(){
    // forward
  if(map[87]){
    if(times[1]<51)
      times[1] ++;
  }
  else{
    if(times[1]==1)
      times[1] = 0;
    if(times[1]>0)
      times[1] -= 2;
  }
    // right
  if(map[68]){
    if(times[0]<51)
      times[0] ++;
  }
  else{
    if(times[0]==1)
      times[0] = 0;
    if(times[0]>0)
      times[0] -= 2;
  }
    // back
  if(map[83]){
    if(times[1]>-51)
      times[1] --;
  }
  else{
    if(times[1]==-1)
      times[1] = 0;
    if(times[1]<0)
      times[1] += 2;
  }
    // left
  if(map[65]){
    if(times[0]>-51)
      times[0] --;
  }
  else{
    if(times[0]==-1)
      times[0] = 0;
    if(times[0]<0)
      times[0] += 2;
  }
}
// Track Keys
onkeydown = onkeyup = function(e){
    e = e || event;
    map[e.keyCode] = e.type == 'keydown';
}
// END:Keep Track of Keys Pressed



// Initialize
window.onload = function(){
  socket = io();
  networkHandle();
  var sleep = window.setInterval(function(){
    if(!connection.up){
      socket.emit('start', "CST");
    }
    else{
      clearInterval(sleep);
    }
  }, 1500);
}


//Translate XY to FRBL
function translateXYtoFRBL(oldArr){
  var newArr = [0,0,0,0];
  if(oldArr[0]<0){
    newArr[1] = 0;
    newArr[3] = -oldArr[0];
  }
  else if(oldArr[0]>0){
    newArr[1] = oldArr[0];
    newArr[3] = 0;
  }
  else{
    newArr[1] = 0;
    newArr[3] = 0;
  }
  if(oldArr[1]<0){
    newArr[0] = 0;
    newArr[2] = -oldArr[1];
  }
  else if(oldArr[1]>0){
    newArr[0] = oldArr[1];
    newArr[2] = 0;
  }
  else{
    newArr[0] = 0;
    newArr[2] = 0;
  }
  return newArr;
}

// Send Directions
var old = {
  array:[0,0,0,0],
  change:[false,false,false,false]
}
function sendDir(socket){
  var input = translateXYtoFRBL(times);
  for(var s=0; s<4; s++){
    if(input[s]!=old.array[s]){
      old.change[s] = true;
      old.array[s] = input[s];
    }
    else{
      old.change[s] = false;
    }
  }
  if(old.change[0]||old.change[2]){
    var endValue = input[0] - input[2];
    if(endValue>0){
      input[0] = endValue;
      input[2] = 0;
      times[2] = 0;
    }
    if(endValue<0){
      input[0] = 0;
      input[0] = 0;
      times[2] = -endValue;

    }
  }
  if(old.change[1]||old.change[3]){
    var endValue = input[1] - input[3];
    if(endValue>0){
      input[1] = endValue;
      input[3] = 0;
      times[3] = 0;
    }
    if(endValue<0){
      times[1] = 0;
      input[1] = 0;
      input[3] = -endValue;
    }
  }
  if(old.change[0]||old.change[1]||old.change[2]||old.change[3]){
    var message = "D";
    var prefixes = ["F", "R", "B", "L"];
    for(var s=0; s<4; s++){
      if(old.change[s]){
        message += prefixes[s];
        message += String(input[s] + 10);
      }
    }
    console.log("Sending Directions: " + message);
    socket.emit('dir', message);
  }
}
// Interval
var dirInterval = setInterval(function(){
  if(connection.up){
    checkkey();
    sendDir(socket);
  }
}, options.dirFreq);



// Hearthbeat
function hearthBeat(socket){
  if(options.ping){
    socket.emit('ping', "CPI");
  }
}

var pingInterval = setInterval(function(){
  hearthBeat();
}, options.pingFreq);


// Change option
function changeOption(option, value){
  switch(option){
    case "ping": 
      if(typeof(options.pingFreq)==typeof(value)){
        clearInterval(pingInterval);
        options.pingFreq = value;
        pingInterval = setInterval(function(){
          hearthBeat();
        }, options.pingFreq);
      }
      else{
        console.log("Error: Type of option is not the same!");
      }
      break;
    case "direction":
      if(typeof(options.dirFreq)==typeof(value)){
        clearInterval(dirInterval);
        options.dirFreq = value;
        dirInterval = setInterval(function(){
          checkkey();
          sendDir(socket);
        }, options.dirFreq);
      }
      else{
        console.log("Error: Type of option is not the same!");
      }
      break;
    default: 
      console.log("Option not found"); break;
  }
}


// Networking
function networkHandle(){
  socket.on('error', function(msg){
    console.log("Error: " + msg);
  });
  socket.on('message', function(msg){
    analizeMessage(msg);
  });
  socket.on('msg', function(msg){
    console.log("Message: " + msg);
  });
  socket.on('disconnect', function(){
    connection.up = false;
  });
}


// Analize Message
function analizeMessage(message){
  console.log("Recieved: " + message);
  var loc = message.substring(0,1);
  var com = message.substring(1,3);
  console.log("Loc: " + loc + " Com: " + com);
  switch(loc){
    case "C":
      switch(com){
        case "UP":
          connection.up = true;
        break;
        case "PO":

        break;
        case "ED":
          connection.up = false;
          console.log("Connection closed: Recieved CED");
        break;
        default: 
          console.log("Unable to read the command (Entered loc:C)");
        break;
      }
      break;
    case "E": 

    break;
    default: 
      console.log("Unable to read the locator");
    break;
  }
}
	</script>
  </body>
</html>
